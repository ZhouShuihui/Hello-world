##  rust表达式和语句
表达式会求值并返回值，语句不返回值，语句中可以包含表达式
-  函数调用是一个表达式,函数定义是语句
-  宏调用是一个表达式
-  创建作用域的代码块是一个表达式,若代码块里没有表达式，即全为语句或为空代码块，则返回空元组()
```rust
 // 非法赋值，因为 let y = 0 为语句，无返回值
let x = （let y = 0);
// 以下{}代码块为表达式
let k = { 
    let x = 3;
    x + 1
    };
```
## 所有权
  clone函数以一种可视化的形式标识了进行消耗资源的拷贝
  - double free内存和悬垂引用不一样，rust编译器保证不会出现上述两种现象
## slice引用不具有所有权
## for循环中in和iter()
## 字符串slice
使用`&str`作为函数参数时，`String`和slice都可以使用这个函数，而使用`&String`作为参数时，只能使用`String`，要使用`&str`，需转化为`String`
## 方法
方法和函数不同
- 方法作用于实例，关联函数作用于？？
- 方法定义于结构体，枚举和trait对象的上下文中，使用`impl` 进行标记，特殊的**方法语法**
- 方法的第一个参数为self
## 自动引用和解引用
当使用`object.something()`调用方法时，Rust 会自动增加`&`、`&mut`或`*`以便使object符合方法的签名。也就是说，这些代码是等同的:
```
a.someting();
&a.someting();
```
**原理**：方法有一个明确的接受者，`self`类型
## 关联函数
使用`::`进行调用
## 枚举
`::`用于创建成员实例，成员可以：不**关联**数据，**关联**元组，**关联**匿名结构体。枚举可以定义方法
##命名空间
使用`::`表示
##  `::`用于结构体，枚举，模块本身调用成员
## match控制流
将一个值与一系列模式进行匹配
- 穷尽匹配
- 通配符\_，与`()`unit值匹配
## 赋值
`count = count + 1`的返回值为`()`

##mod
- 使用`cargo build`
- 命名空间语法`::`
- Rust默认只知道src/lib.rs的内容
- 通过`super`向上引用
## vector
- 类型必须相同
- 两种获得元素引用的方法
- 和枚举
